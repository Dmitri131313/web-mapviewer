import { EditableFeature, EditableFeatureTypes } from '@/api/features.api'
import { MEDIUM, RED } from '@/utils/featureStyleUtils'
import { expect } from 'chai'
import { describe, it } from 'vitest'
import KML from 'ol/format/KML'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import { CoordinateSystems } from '@/utils/coordinateUtils'
import * as featureStyle from '@/utils/featureStyleUtils'

const args = {
    id: 'drawing_feature_2',
    coordinates: null,
    title: 'This is a title',
    featureType: EditableFeatureTypes.ANNOTATION,
}
const testObject = {
    ...args,
    description: '',
    textColor: RED,
    textSize: MEDIUM,
    fillColor: RED,
    icon: null,
    iconSize: MEDIUM,
}
const stringifiedTestObject = `{"id":"drawing_feature_2",\
"coordinates":null,\
"title":"This is a title",\
"description":"",\
"featureType":"ANNOTATION",\
"textColor":{"name":"red","fill":"#ff0000","border":"#ffffff"},\
"fillColor":{"name":"red","fill":"#ff0000","border":"#ffffff"},\
"textSize":{"label":"medium_size","textScale":1.5,"iconScale":1},\
"icon":null,\
"iconSize":{"label":"medium_size","textScale":1.5,"iconScale":1}}`

describe('Validate features api', () => {
    describe('Validate serialization and deserialization of the editable feature', () => {
        it('Serialize a default editable feature', () => {
            const feature = EditableFeature.constructWithObject(args)
            expect(feature).to.be.instanceOf(EditableFeature)
            const stringified = JSON.stringify(feature.getStrippedObject())
            // Cannot directly compare the two strings, as the order is undefined
            expect(JSON.parse(stringified)).to.deep.equal(JSON.parse(stringifiedTestObject))
        })
        it('Deserialize a default editable feature', () => {
            const reconstructed = EditableFeature.recreateObject(JSON.parse(stringifiedTestObject))
            expect(reconstructed).to.be.instanceOf(EditableFeature)
            expect(reconstructed.id).to.be.equal(testObject.id)
            expect(reconstructed.coordinates).to.be.equal(testObject.coordinates)
            expect(reconstructed.title).to.be.equal(testObject.title)
            expect(reconstructed.description).to.be.equal(testObject.description)
            expect(reconstructed.icon).to.be.equal(testObject.icon)

            /* If theses classes are extended to save more data than what is serialized, these tests
            will need to be changed*/
            expect(reconstructed.textColor).to.deep.equal(testObject.textColor)
            expect(reconstructed.textSize).to.deep.equal(testObject.textSize)
            expect(reconstructed.fillColor).to.deep.equal(testObject.fillColor)
            expect(reconstructed.iconSize).to.deep.equal(testObject.iconSize)
            expect(reconstructed.featureType).to.deep.equal(testObject.featureType)
        })
    })
    describe('Validate deserialization of the mf-geoadmin3 viewer kml format', () => {
        it('deserialize kml file generated by the old viewer', async () => {
            const kml = readFileSync(resolve(__dirname, './mfgeoadmin3TestKml.kml'), 'utf8')
            const olFeatures = new KML().readFeatures(kml, {
                featureProjection: CoordinateSystems.WEBMERCATOR.epsg,
            })
            let features = []
            for (const olFeature of olFeatures) {
                await EditableFeature.deserialize(olFeature)
                const feature = olFeature.get('editableFeature')
                feature.olFeature = olFeature
                features.push(feature)
            }
            features.sort((a, b) => {
                const elemA = Number(
                    a.title.match(/^text ([0-9]+)$/)?.[1] ??
                        a.description.match(/^desc ([0-9]+)$/)?.[1] ??
                        a.id.match(/^drawing_feature_([0-9]+)$/)?.[1] ??
                        '0'
                )
                const elemB = Number(
                    b.title.match(/^text ([0-9]+)$/)?.[1] ??
                        b.description.match(/^desc ([0-9]+)$/)?.[1] ??
                        b.id.match(/^drawing_feature_([0-9]+)$/)?.[1] ??
                        '0'
                )
                return elemA - elemB
            })
            features.forEach((feature, i) => {
                i++
                const olCoords = feature.olFeature.getGeometry().getCoordinates()
                let olCoord = olCoords
                while (Array.isArray(olCoord?.[0])) {
                    olCoord = olCoord[0]
                }
                //Check that we correctly removed the z coordinate (height)
                expect(olCoord).to.have.length(2)
                expect(feature.id).to.match(/^drawing_feature_[0-9]+$/)
                //Markers
                if (i <= 3) {
                    expect(feature.coordinates).to.have.length(2)
                    expect(olCoords).to.have.length(2)
                    expect(feature.title).to.be.equal('text ' + i)
                    expect(feature.description).to.be.equal('desc ' + i)
                    expect(feature.featureType).to.be.equal(EditableFeatureTypes.MARKER)
                    expect(feature.textColor).to.be.equal(
                        i === 1
                            ? featureStyle.YELLOW
                            : i === 2
                            ? featureStyle.WHITE
                            : featureStyle.RED
                    )
                    expect(feature.textSize).to.be.equal(
                        i === 1
                            ? featureStyle.LARGE
                            : i === 2
                            ? featureStyle.VERY_SMALL
                            : featureStyle.MEDIUM
                    )
                    expect(feature.fillColor).to.be.equal(
                        i === 1 ? featureStyle.BLUE : i === 2 ? featureStyle.GRAY : featureStyle.RED
                    )
                    expect(feature.iconSize).to.be.equal(
                        i === 1
                            ? featureStyle.VERY_SMALL
                            : i === 2
                            ? featureStyle.SMALL
                            : featureStyle.MEDIUM
                    )
                    expect(feature.icon.name).to.be.equal(
                        i === 1 ? '001-marker' : i === 2 ? '002-circle' : 'babs-3'
                    )
                }
                //Text fields
                else if (i <= 6) {
                    expect(feature.coordinates).to.have.length(2)
                    expect(olCoords).to.have.length(2)
                    expect(feature.title).to.be.equal('text ' + i)
                    expect(feature.description).to.be.equal('')
                    expect(feature.featureType).to.be.equal(EditableFeatureTypes.ANNOTATION)
                    expect(feature.textColor).to.be.equal(
                        i === 4
                            ? featureStyle.BLACK
                            : i === 5
                            ? featureStyle.BLUE
                            : featureStyle.GRAY
                    )
                    expect(feature.textSize).to.be.equal(
                        i === 4
                            ? featureStyle.VERY_SMALL
                            : i === 5
                            ? featureStyle.MEDIUM
                            : featureStyle.LARGE
                    )
                    expect(feature.fillColor).to.be.equal(featureStyle.RED)
                    expect(feature.iconSize).to.be.equal(featureStyle.MEDIUM)
                    expect(feature.icon).to.be.null
                }
                //Lines
                else if (i <= 9) {
                    // i=9 is a polygon while the other lines are linestrings
                    expect(feature.coordinates).to.have.length(i === 9 ? 5 : 2)
                    expect(olCoords).to.have.length(i === 9 ? 1 : 2)
                    if (i === 9) {
                        expect(olCoords[0]).to.have.length(5)
                    }
                    expect(feature.title).to.be.equal('')
                    expect(feature.description).to.be.equal('desc ' + i)
                    expect(feature.featureType).to.be.equal(EditableFeatureTypes.LINEPOLYGON)
                    expect(feature.textColor).to.be.equal(featureStyle.RED)
                    expect(feature.textSize).to.be.equal(featureStyle.MEDIUM)
                    expect(feature.fillColor).to.be.equal(
                        i === 7
                            ? featureStyle.BLACK
                            : i === 8
                            ? featureStyle.BLUE
                            : featureStyle.YELLOW
                    )
                    expect(feature.iconSize).to.be.equal(featureStyle.MEDIUM)
                    expect(feature.icon).to.be.null
                }
                //Marker without text
                else if (i === 10) {
                    expect(feature.coordinates).to.have.length(2)
                    expect(olCoords).to.have.length(2)
                    expect(feature.title).to.be.equal('')
                    expect(feature.description).to.be.equal('desc ' + i)
                    expect(feature.featureType).to.be.equal(EditableFeatureTypes.MARKER)
                    // For the text, the default values of red and medium should be selected
                    expect(feature.textColor).to.be.equal(featureStyle.RED)
                    expect(feature.textSize).to.be.equal(featureStyle.MEDIUM)
                    expect(feature.fillColor).to.be.equal(featureStyle.GREEN)
                    expect(feature.iconSize).to.be.equal(featureStyle.MEDIUM)
                    expect(feature.icon.name).to.be.equal('003-square')
                }
                //Measures
                else {
                    expect(feature.coordinates).to.have.length(i === 11 ? 2 : 3)
                    expect(olCoords).to.have.length(i === 11 ? 2 : 3)
                    expect(feature.title).to.be.equal('')
                    expect(feature.description).to.be.equal('')
                    expect(feature.featureType).to.be.equal(EditableFeatureTypes.MEASURE)
                    expect(feature.textColor).to.be.equal(featureStyle.RED)
                    expect(feature.textSize).to.be.equal(featureStyle.MEDIUM)
                    expect(feature.fillColor).to.be.equal(featureStyle.RED)
                    expect(feature.iconSize).to.be.equal(featureStyle.MEDIUM)
                    expect(feature.icon).to.be.null
                }
            })
        })
    })
})
